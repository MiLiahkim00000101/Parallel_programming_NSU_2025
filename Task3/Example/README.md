# Многопоточные примеры на C++

Этот репозиторий содержит примеры кода, демонстрирующие работу с многопоточностью в C++.

## Описание файлов

### 1. `argsThread.cpp`
Демонстрация создания потоков и передачи аргументов им с использованием:
- Обычной функции
- Функционального объекта (класса с перегруженным `operator()`).
- Лямбда-функции.

### 2. `async_lazy_eager.cpp`
Показана разница между:
- `std::launch::deferred` (ленивое выполнение, запуск происходит при вызове `get()`)
- `std::launch::async` (немедленный запуск в отдельном потоке).

### 3. `barrierWorkers.cpp`
Использование `std::barrier` для синхронизации нескольких потоков. Каждый поток выполняет работу и ожидает остальных перед продолжением.

### 4. `cond_var.cpp`
Демонстрация использования `std::condition_variable` для организации ожидания события между потоками.

### 5. `createThread.cpp`
Различные способы создания потоков:
- Передача обычной функции
- Использование функционального объекта
- Лямбда-функция

### 6. `deadlock.cpp`
Пример возникновения взаимной блокировки (`deadlock`) при использовании двух `std::mutex`.

### 7. `interrupt_jthread.cpp`
Использование `std::jthread` и `std::stop_token` для безопасного прерывания потоков.

### 8. `jthread.cpp`
Пример работы `std::jthread`, который автоматически завершает поток при выходе из области видимости.

### 9. `jthread_stop_callback.cpp`
Использование `std::stop_callback` для регистрации обработчика, вызываемого при остановке `std::jthread`.

### 10. `latchWorkers.cpp`
Применение `std::latch` для синхронизации завершения работы потоков.

### 11. `lock_guard.cpp`
Демонстрация использования `std::lock_guard` и `std::unique_lock` для управления мьютексами.

### 12. `mutex.cpp`
Пример ручной блокировки и разблокировки `std::mutex` в многопоточной среде.

### 13. `package_task.cpp`
Использование `std::packaged_task` для выполнения задач с последующим получением результата через `std::future`.

### 14. `promise_and_future.cpp`
Передача данных между потоками с использованием `std::promise` и `std::future`, а также обработка исключений.

### 15. `scoped_lock.cpp`
Пример использования `std::scoped_lock` для безопасного захвата нескольких мьютексов и предотвращения deadlock.

### 16. `shared_mutex.cpp`
Использование `std::shared_mutex` для разделения доступа к ресурсам между потоками чтения и записи.

### 17. `signal.cpp`
Обработка сигнала `SIGFPE` (ошибка арифметики, например, деление на ноль).

### 18. `syncThreadSemaphore.cpp`
Демонстрация использования `std::counting_semaphore` для синхронизации выполнения потоков.

### 19. `task_vs_thread.cpp`
Разница между `std::thread` и `std::async` при выполнении задач в многопоточной среде.

### 20. `thread.cpp`
Базовый пример создания и запуска потока в C++ с `std::thread`.

### 21. `thread_detach.cpp`
Использование `std::thread::detach()` для отделения потока от основного выполнения.

### 22. `thread_local.cpp`
Применение `thread_local` переменных для создания данных, уникальных для каждого потока.

### 23. `wait_future.cpp`
Использование `std::future::wait_for()` для неблокирующего ожидания результата выполнения асинхронной задачи.

## Компиляции
Для компиляции примеров используйте команды:
```sh
 cmake -B build -S . -DCMAKE_CXX_COMPILER=g++
 cmake --build build/ -j 10
```

## Запуск
Для запуска примеров используйте команду:
```sh
 ./build/bin/<compile>/<name_program>
```
- compile - имя компилятора
- name_program - имя программы, образуется от имени исходного файла

## Требования
- Компилятор с поддержкой C++20 (`g++` 10+ или `clang++` 10+).
- Поддержка многопоточного программирования (`-pthread`).
