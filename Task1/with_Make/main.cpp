#include <iostream>
#include <cmath>
#include <vector>

#ifdef FLOATVALUESIN
    float temp = 0;
    float temp_sin_val; 
    float res = 0;
#else
    double temp = 0;
    double temp_sin_val;
    double res = 0;
#endif


int main(){

    
    for (int i = 0; i < 10000000; ++i){

        temp_sin_val = sin(temp);
        res += temp_sin_val;
        temp = (2 * M_PI * i) / 10000000; // В этом случае мы довольно точно обозначаем число
        // temp и не аккумулируем его, как следствие счет получается довольно точен как для double так и для float
        
        
        // Неверный способ использования: temp += 2 * M_PI / 10000000;
        // здесь за такое огромное количество итераций если выбран
        // float накапливается большая ошибка из игнорирования малых значений после запятой
        //(мне кажется, что ошибка накапливается за счет игнорирования значений
        // после 10 знака(после запятой) до того, как мы получили целую часть и после 5-7 после). 
        // Из-за устройства чисел с плавающей запятой в компьютерах, чем дальше от нуля число 
        // тем менее точно оно будет определяться.
        // Здесь вышла именно такая ситуация, ведь отдаляясь от нуля значение temp начинает меняться
        // все медленнее и медленнее, в итоге мы даже не можем пройти весь период((((


        
    }

    std::cout << res << std::endl;

    return 0;

}